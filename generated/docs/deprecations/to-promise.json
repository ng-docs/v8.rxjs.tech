{"id":"deprecations/to-promise","title":"转换为 Promise（承诺）","contents":"\n<div class=\"content\">\n<h1 id=\"conversion-to-promises\" translation-result=\"on\">转换为 Promise（承诺）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#conversion-to-promises\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">Conversion to Promises<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#conversion-to-promises\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">Observables 和 Promises 的相似之处在于，随着时间的推移，这两个<a href=\"/guide/observable\">集合</a>都可能产生值，但不同之处在于 Observables 可能不产生或产生多个值，而 Promises 在成功解析时只产生一个值。</p><p translation-origin=\"off\">The similarity between Observables and Promises is that both <a href=\"/guide/observable\">collections</a> may produce values over\ntime, but the difference is that Observables may produce none or more than one value, while Promises produce only one\nvalue when resolved successfully.</p>\n\n<h2 id=\"issues\" translation-result=\"on\">问题<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#issues\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Issues<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#issues\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">出于这个原因，在 RxJS 7 中，Observable 的 <a href=\"/api/index/class/Observable#toPromise\"><code>toPromise()</code></a> 方法的返回类型已被修复，以更好地反映 Observable 可以产生零个值的事实。这可能对于某些项目是<strong>重大更改</strong>，因为返回类型已从 <code>Promise&lt;T&gt;</code> 更改为 <code>Promise&lt;T | undefined&gt;</code>。</p><p translation-origin=\"off\">For this reason, in RxJS 7, the return type of the Observable's <a href=\"/api/index/class/Observable#toPromise\"><code>toPromise()</code></a>\nmethod has been fixed to better reflect the fact that Observables can yield zero values. This may be a <strong>breaking\nchange</strong> to some projects as the return type was changed from <code>Promise&lt;T&gt;</code> to <code>Promise&lt;T | undefined&gt;</code>.</p>\n\n<p translation-result=\"on\">此外，<code>toPromise()</code> 这个方法名无法指出 Promise 将使用什么发出的值来解决（resolve），因为 Observables 可以随着时间的推移产生多个值。转换为 Promise 时，你可能需要选择要选取的值 - 是抵达的第一个值还是最后一个值。为了解决所有这些问题，我们决定弃用 <code>toPromise()</code>，并引入两个新的辅助函数来转换为 Promise。</p><p translation-origin=\"off\">Also, <code>toPromise()</code> method name was never indicating what emitted value a Promise will resolve with because Observables\ncan produce multiple values over time. When converting to a Promise, you might want to choose which value to pick -\neither the first value that has arrived or the last one. To fix all these issues, we decided to deprecate <code>toPromise()</code>,\nand to introduce the two new helper functions for conversion to Promises.</p>\n\n<h2 id=\"use-one-of-the-two-new-functions\" translation-result=\"on\">使用两个新函数之一<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#use-one-of-the-two-new-functions\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Use one of the two new functions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#use-one-of-the-two-new-functions\"><i class=\"material-icons\">link</i></a></h2>\n\n<p>As a replacement to the deprecated <code>toPromise()</code> method, you should use one of the two built in static conversion\nfunctions <a href=\"api/index/function/firstValueFrom\"><code>firstValueFrom</code></a> or <a href=\"api/index/function/lastValueFrom\"><code>lastValueFrom</code></a>.</p>\n<h3 id=\"lastvaluefrom\"><code><a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#lastvaluefrom\"><i class=\"material-icons\">link</i></a></h3>\n<p>The <code><a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a></code> is almost exactly the same as <code>toPromise()</code> meaning that it will resolve with the last value that has\narrived when the Observable completes, but with the difference in behavior when Observable completes without emitting a\nsingle value. When Observable completes without emitting, <code>toPromise()</code> will successfully resolve with <code>undefined</code> (thus\nthe return type change), while the <code><a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a></code> will reject with the <a href=\"api/index/interface/EmptyError\"><code>EmptyError</code></a>. Thus, the return type of the\n<code><a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a></code> is <code>Promise&lt;T&gt;</code>, just like <code>toPromise()</code> had in RxJS 6.</p>\n<h4 id=\"example\" translation-result=\"on\">例子<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#example\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Example<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#example\"><i class=\"material-icons\">link</i></a></h4>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/index/function/interval\" class=\"code-anchor\">interval</a>, <a href=\"api/index/function/take\" class=\"code-anchor\">take</a>, <a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a> } from 'rxjs';\n\nasync function execute() {\n  const source$ = <a href=\"api/index/function/interval\" class=\"code-anchor\">interval</a>(2000).pipe(<a href=\"api/index/function/take\" class=\"code-anchor\">take</a>(10));\n  const finalNumber = await <a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a>(source$);\n  console.log(`The final number is ${finalNumber}`);\n}\n\nexecute();\n\n// Expected output:\n// \"The final number is 9\"\n</code-example>\n<h3 id=\"firstvaluefrom\"><code><a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#firstvaluefrom\"><i class=\"material-icons\">link</i></a></h3>\n<p>However, you might want to take the first value as it arrives without waiting an Observable to complete, thus you can\nuse <code><a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a></code>. The <code><a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a></code> will resolve a Promise with the first value that was emitted from the\nObservable and will immediately unsubscribe to retain resources. The <code><a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a></code> will also reject with an\n<a href=\"api/index/interface/EmptyError\"><code>EmptyError</code></a> if the Observable completes with no values emitted.</p>\n<h4 id=\"example-1\" translation-result=\"on\">例子<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#example-1\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Example<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#example-1\"><i class=\"material-icons\">link</i></a></h4>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/index/function/interval\" class=\"code-anchor\">interval</a>, <a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a> } from 'rxjs';\n\nasync function execute() {\n  const source$ = <a href=\"api/index/function/interval\" class=\"code-anchor\">interval</a>(2000);\n  const firstNumber = await <a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a>(source$);\n  console.log(`The <a href=\"api/index/function/first\" class=\"code-anchor\">first</a> number is ${firstNumber}`);\n}\n\nexecute();\n\n// Expected output:\n// \"The <a href=\"api/index/function/first\" class=\"code-anchor\">first</a> number is 0\"\n</code-example>\n<p><span class=\"informal\">Both functions will return a Promise that rejects if the source Observable errors. The Promise\nwill reject with the same error that the Observable has errored with.</span></p>\n<h2 id=\"use-default-value\" translation-result=\"on\">使用默认值<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#use-default-value\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Use default value<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#use-default-value\"><i class=\"material-icons\">link</i></a></h2>\n\n<p>If you don't want Promises created by <code><a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a></code> or <code><a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a></code> to reject with <a href=\"api/index/interface/EmptyError\"><code>EmptyError</code></a> if there\nwere no emissions before completion, you can use the second parameter. The second parameter is expected to be an object\nwith <code>defaultValue</code> parameter. The value in the <code>defaultValue</code> will be used to resolve a Promise when source Observable\ncompletes without emitted values.</p>\n<code-example language=\"ts\">\nimport { <a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a>, <a href=\"api/index/const/EMPTY\" class=\"code-anchor\">EMPTY</a> } from 'rxjs';\n\nconst result = await <a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a>(<a href=\"api/index/const/EMPTY\" class=\"code-anchor\">EMPTY</a>, { defaultValue: 0 });\nconsole.log(result);\n\n// Expected output:\n// 0\n</code-example>\n<h2 id=\"warning\" translation-result=\"on\">警告<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#warning\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Warning<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#warning\"><i class=\"material-icons\">link</i></a></h2>\n\n<p>Only use <code><a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a></code> function if you <em>know</em> an Observable will eventually complete. The <code><a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a></code> function should\nbe used if you <em>know</em> an Observable will emit at least one value <em>or</em> will eventually complete. If the source Observable\ndoes not complete or emit, you will end up with a Promise that is hung up, and potentially all of the state of an async\nfunction hanging out in memory. To avoid this situation, look into adding something like <a href=\"api/index/function/timeout\"><code>timeout</code></a>, <a href=\"api/index/function/take\"><code>take</code></a>,\n<a href=\"api/index/function/takeWhile\"><code>takeWhile</code></a>, or <a href=\"api/index/function/takeUntil\"><code>takeUntil</code></a> amongst others.</p>\n\n</div>\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - /api/index/class/Observable#toPromise\n - /guide/observable\n - api/index/const/EMPTY\n - api/index/function/first\n - api/index/function/firstValueFrom\n - api/index/function/interval\n - api/index/function/lastValueFrom\n - api/index/function/take\n - api/index/function/takeUntil\n - api/index/function/takeWhile\n - api/index/function/timeout\n - api/index/interface/EmptyError\n - deprecations/to-promise#conversion-to-promises\n - deprecations/to-promise#example\n - deprecations/to-promise#example-1\n - deprecations/to-promise#firstvaluefrom\n - deprecations/to-promise#issues\n - deprecations/to-promise#lastvaluefrom\n - deprecations/to-promise#use-default-value\n - deprecations/to-promise#use-one-of-the-two-new-functions\n - deprecations/to-promise#warning\n - deprecations/to-promise#使用两个新函数之一\n - deprecations/to-promise#使用默认值\n - deprecations/to-promise#例子\n - deprecations/to-promise#例子-1\n - deprecations/to-promise#警告\n - deprecations/to-promise#转换为-promise承诺\n - deprecations/to-promise#问题\n-->"}