{"id":"guide/observable","title":"Observable(可观察者)","contents":"\n<div class=\"content\">\n<h1 id=\"observable\" translation-result=\"on\">Observable(可观察者)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observable#observable\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">Observable<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observable#observable\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">Observable 是个多值的惰性 Push 集合。他们填补了下表中的缺失点：</p><p translation-origin=\"off\">Observables are lazy Push collections of multiple values. They fill the missing spot in the following table:</p>\n\n<table>\n<thead>\n<tr>\n<th></th>\n<th><nt-wrapper translation-result=\"on\">单值</nt-wrapper><nt-wrapper translation-origin=\"off\">Single</nt-wrapper></th>\n<th><nt-wrapper translation-result=\"on\">多值</nt-wrapper><nt-wrapper translation-origin=\"off\">Multiple</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td><nt-wrapper translation-result=\"on\"><strong>拉</strong></nt-wrapper><nt-wrapper translation-origin=\"off\"><strong>Pull</strong></nt-wrapper></td>\n<td><a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Function\"><code>Function</code></a></td>\n<td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols\"><code>Iterator</code></a></td>\n</tr>\n\n<tr>\n<td><nt-wrapper translation-result=\"on\"><strong>推</strong></nt-wrapper><nt-wrapper translation-origin=\"off\"><strong>Push</strong></nt-wrapper></td>\n<td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\"><code>Promise</code></a></td>\n<td><a href=\"/api/index/class/Observable\"><code>Observable</code></a></td>\n</tr>\n\n</tbody>\n</table>\n<p translation-result=\"on\"><strong>例子。</strong>下面是一个 Observable，它在订阅时立即（同步）推送值 <code>1</code>、<code>2</code>、<code>3</code>，并且在 subscribe 调用过一秒之后推送值 <code>4</code>，然后完成：</p><p translation-origin=\"off\"><strong>Example.</strong> The following is an Observable that pushes the values <code>1</code>, <code>2</code>, <code>3</code> immediately (synchronously) when subscribed, and the value <code>4</code> after one second has passed since the subscribe call, then completes:</p>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a> } from 'rxjs';\n\nconst <a href=\"api/index/const/observable\" class=\"code-anchor\">observable</a> = new <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>((subscriber) =&gt; {\n  subscriber.next(1);\n  subscriber.next(2);\n  subscriber.next(3);\n  setTimeout(() =&gt; {\n    subscriber.next(4);\n    subscriber.complete();\n  }, 1000);\n});\n</code-example>\n<p translation-result=\"on\">要调用 Observable 并查看这些值，我们需要<em>订阅</em>它：</p><p translation-origin=\"off\">To invoke the Observable and see these values, we need to <em>subscribe</em> to it:</p>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a> } from 'rxjs';\n\nconst <a href=\"api/index/const/observable\" class=\"code-anchor\">observable</a> = new <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>((subscriber) =&gt; {\n  subscriber.next(1);\n  subscriber.next(2);\n  subscriber.next(3);\n  setTimeout(() =&gt; {\n    subscriber.next(4);\n    subscriber.complete();\n  }, 1000);\n});\n\nconsole.log('just before subscribe');\nobservable.subscribe({\n  next(x) {\n    console.log('got value ' + x);\n  },\n  error(err) {\n    console.error('something wrong occurred: ' + err);\n  },\n  complete() {\n    console.log('done');\n  },\n});\nconsole.log('just after subscribe');\n</code-example>\n<p translation-result=\"on\">在控制台上执行结果如下：</p><p translation-origin=\"off\">Which executes as such on the console:</p>\n\n<code-example language=\"none\">\njust before subscribe\ngot value 1\ngot value 2\ngot value 3\njust after subscribe\ngot value 4\ndone\n</code-example>\n<h2 id=\"pull-versus-push\" translation-result=\"on\">拉取与推送<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observable#pull-versus-push\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Pull versus Push<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observable#pull-versus-push\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\"><em>拉取（Pull）</em>和<em>推送（Push）</em>是两种不同的协议，用于描述数据<em>生产者（Producer）</em>如何与数据<em>消费者（Consumer）</em>通信。</p><p translation-origin=\"off\"><em>Pull</em> and <em>Push</em> are two different protocols that describe how a data <em>Producer</em> can communicate with a data <em>Consumer</em>.</p>\n\n<p translation-result=\"on\"><strong>什么是拉取？</strong>在拉取体系中，由消费者确定何时从数据生产者接收数据。而生产者本身不知道数据何时交付给消费者。</p><p translation-origin=\"off\"><strong>What is Pull?</strong> In Pull systems, the Consumer determines when it receives data from the data Producer. The Producer itself is unaware of when the data will be delivered to the Consumer.</p>\n\n<p translation-result=\"on\">每个 JavaScript 函数都是一个拉取系统。该函数是数据的生产者，调用该函数的代码通过从其调用中“拉取”出<em>单个</em>返回值来使用它。</p><p translation-origin=\"off\">Every JavaScript Function is a Pull system. The function is a Producer of data, and the code that calls the function is consuming it by \"pulling\" out a <em>single</em> return value from its call.</p>\n\n<p translation-result=\"on\">ES2015 引入了<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*\">生成器函数和迭代器</a>（<code>function*</code>），它是另一种类型的拉取体系。调用 <code>iterator.next()</code> 的代码是消费者，它从迭代器（生产者）“拉取”出<em>多个</em>值。</p><p translation-origin=\"off\">ES2015 introduced <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*\">generator functions and iterators</a> (<code>function*</code>), another type of Pull system. Code that calls <code>iterator.next()</code> is the Consumer, \"pulling\" out <em>multiple</em> values from the iterator (the Producer).</p>\n\n<table>\n<thead>\n<tr>\n<th></th>\n<th><nt-wrapper translation-result=\"on\">生产者</nt-wrapper><nt-wrapper translation-origin=\"off\">Producer</nt-wrapper></th>\n<th><nt-wrapper translation-result=\"on\">消费者</nt-wrapper><nt-wrapper translation-origin=\"off\">Consumer</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td><nt-wrapper translation-result=\"on\"><strong>拉取</strong></nt-wrapper><nt-wrapper translation-origin=\"off\"><strong>Pull</strong></nt-wrapper></td>\n<td><nt-wrapper translation-result=\"on\"><strong>被动：</strong>在请求时产生数据。</nt-wrapper><nt-wrapper translation-origin=\"off\"><strong>Passive:</strong> produces data when requested.</nt-wrapper></td>\n<td><nt-wrapper translation-result=\"on\"><strong>主动：</strong>决定何时请求数据。</nt-wrapper><nt-wrapper translation-origin=\"off\"><strong>Active:</strong> decides when data is requested.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td><nt-wrapper translation-result=\"on\"><strong>推送</strong></nt-wrapper><nt-wrapper translation-origin=\"off\"><strong>Push</strong></nt-wrapper></td>\n<td><nt-wrapper translation-result=\"on\"><strong>主动：</strong>按照自己的节奏生成数据。</nt-wrapper><nt-wrapper translation-origin=\"off\"><strong>Active:</strong> produces data at its own pace.</nt-wrapper></td>\n<td><nt-wrapper translation-result=\"on\"><strong>被动：</strong>对接收到的数据做出响应。</nt-wrapper><nt-wrapper translation-origin=\"off\"><strong>Passive:</strong> reacts to received data.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p translation-result=\"on\"><strong>什么是推送？</strong>在推送体系中，由生产者决定何时向消费者发送数据。而消费者不知道何时会收到该数据。</p><p translation-origin=\"off\"><strong>What is Push?</strong> In Push systems, the Producer determines when to send data to the Consumer. The Consumer is unaware of when it will receive that data.</p>\n\n<p translation-result=\"on\">Promise 是当今 JavaScript 中最常见的推送体系类型。Promise（生产者）向已注册的回调（消费者）传递解析后的值，但与函数不同的是，Promise 负责准确确定该值何时“推送”到回调。</p><p translation-origin=\"off\">Promises are the most common type of Push system in JavaScript today. A Promise (the Producer) delivers a resolved value to registered callbacks (the Consumers), but unlike functions, it is the Promise which is in charge of determining precisely when that value is \"pushed\" to the callbacks.</p>\n\n<p translation-result=\"on\">RxJS 引入了 Observables，一个新的 JavaScript 推送体系。Observable 是多个值的生产者，并将它们“推送”给 Observer（消费者）。</p><p translation-origin=\"off\">RxJS introduces Observables, a new Push system for JavaScript. An Observable is a Producer of multiple values, \"pushing\" them to Observers (Consumers).</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><strong>函数</strong>是一种惰性求值的计算，它在调用时同步返回单个值。</p><p translation-origin=\"off\">A <strong>Function</strong> is a lazily evaluated computation that synchronously returns a single value on invocation.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><strong>生成器</strong>是一种惰性求值的计算，它在迭代时同步返回零到（可能）无限个值。</p><p translation-origin=\"off\">A <strong>generator</strong> is a lazily evaluated computation that synchronously returns zero to (potentially) infinite values on iteration.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><strong>Promise</strong> 是一种可能会（也可能不会）最终返回单个值的计算。</p><p translation-origin=\"off\">A <strong>Promise</strong> is a computation that may (or may not) eventually return a single value.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><strong>Observable</strong> 是一种惰性求值的计算，从它被调用的那一刻起，它可以同步或异步返回零个到（可能）无限个值。</p><p translation-origin=\"off\">An <strong>Observable</strong> is a lazily evaluated computation that can synchronously or asynchronously return zero to (potentially) infinite values from the time it's invoked onwards.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\"><span class=\"informal\">有关应该使用什么将 Observables 转换为 Promise 的更多信息，请参阅<a href=\"/deprecations/to-promise\">本指南</a>。</span></p><p translation-origin=\"off\"><span class=\"informal\">For more info about what to use when converting Observables to Promises, please refer to <a href=\"/deprecations/to-promise\">this guide</a>.</span></p>\n\n<h2 id=\"observables-as-generalizations-of-functions\" translation-result=\"on\">Observables 是对函数的泛化<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observable#observables-as-generalizations-of-functions\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Observables as generalizations of functions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observable#observables-as-generalizations-of-functions\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">与流行的说法相反，Observables 不像 EventEmitters 或 Promises 那样用于多个值。在某些情况下，Observable 的<em>行为可能</em>类似于 EventEmitter，也就是当它们使用 RxJS Subject 进行多播时，但通常它们的行为不像 EventEmitters。</p><p translation-origin=\"off\">Contrary to popular claims, Observables are not like EventEmitters nor are they like Promises for multiple values. Observables <em>may act</em> like EventEmitters in some cases, namely when they are multicasted using RxJS Subjects, but usually they don't act like EventEmitters.</p>\n\n<p translation-result=\"on\"><span class=\"informal\">Observables 类似于无参的函数，但会将它们泛化为允许多个值。</span></p><p translation-origin=\"off\"><span class=\"informal\">Observables are like functions with zero arguments, but generalize those to allow multiple values.</span></p>\n\n<p translation-result=\"on\">考虑下列代码：</p><p translation-origin=\"off\">Consider the following:</p>\n\n<code-example language=\"ts\">\nfunction foo() {\n  console.log('Hello');\n  return 42;\n}\n\nconst x = foo.call(); // same as foo()\nconsole.log(x);\nconst y = foo.call(); // same as foo()\nconsole.log(y);\n</code-example>\n<p translation-result=\"on\">我们希望看到如下输出：</p><p translation-origin=\"off\">We expect to see as output:</p>\n\n<code-example language=\"none\">\n\"Hello\"\n42\n\"Hello\"\n42\n</code-example>\n<p translation-result=\"on\">你可以写出与刚才一样的行为，但改用 Observables：</p><p translation-origin=\"off\">You can write the same behavior above, but with Observables:</p>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a> } from 'rxjs';\n\nconst foo = new <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>((subscriber) =&gt; {\n  console.log('Hello');\n  subscriber.next(42);\n});\n\nfoo.subscribe((x) =&gt; {\n  console.log(x);\n});\nfoo.subscribe((y) =&gt; {\n  console.log(y);\n});\n</code-example>\n<p translation-result=\"on\">其输出是一样的：</p><p translation-origin=\"off\">And the output is the same:</p>\n\n<code-example language=\"none\">\n\"Hello\"\n42\n\"Hello\"\n42\n</code-example>\n<p translation-result=\"on\">这是因为函数和 Observable 都是惰性计算的。如果你不调用该函数，<code>console.log('Hello')</code> 就不会发生。同样对于 Observables，如果你不“调用”它（使用 <code>subscribe</code>），<code>console.log('Hello')</code> 就不会发生。另外，“调用”或“订阅”都是一种孤立的操作：两个函数调用会触发两个单独的副作用，两个对 Observable 的订阅会触发两个单独的副作用。与 EventEmitter 共享副作用并且无论订阅者是否存在都急性执行相反，Observables 不会共享执行并且是惰性的。</p><p translation-origin=\"off\">This happens because both functions and Observables are lazy computations. If you don't call the function, the <code>console.log('Hello')</code> won't happen. Also with Observables, if you don't \"call\" it (with <code>subscribe</code>), the <code>console.log('Hello')</code> won't happen. Plus, \"calling\" or \"subscribing\" is an isolated operation: two function calls trigger two separate side effects, and two Observable subscribes trigger two separate side effects. As opposed to EventEmitters which share the side effects and have eager\nexecution regardless of the existence of subscribers, Observables have no shared execution and are lazy.</p>\n\n<p translation-result=\"on\"><span class=\"informal\">订阅 Observable 类似于调用函数。</span></p><p translation-origin=\"off\"><span class=\"informal\">Subscribing to an Observable is analogous to calling a Function.</span></p>\n\n<p translation-result=\"on\">有些人声称 Observables 是异步的。那不是真的。如果你使用日志来包裹函数调用，如下所示：</p><p translation-origin=\"off\">Some people claim that Observables are asynchronous. That is not true. If you surround a function call with logs, like this:</p>\n\n<code-example language=\"ts\">\nconsole.log('before');\nconsole.log(foo.call());\nconsole.log('after');\n</code-example>\n<p translation-result=\"on\">你将看到输出：</p><p translation-origin=\"off\">You will see the output:</p>\n\n<code-example language=\"none\">\n\"before\"\n\"Hello\"\n42\n\"after\"\n</code-example>\n<p translation-result=\"on\">这与 Observables 的行为相同：</p><p translation-origin=\"off\">And this is the same behavior with Observables:</p>\n\n<code-example language=\"ts\">\nconsole.log('before');\nfoo.subscribe((x) =&gt; {\n  console.log(x);\n});\nconsole.log('after');\n</code-example>\n<p translation-result=\"on\">其输出是：</p><p translation-origin=\"off\">And the output is:</p>\n\n<code-example language=\"none\">\n\"before\"\n\"Hello\"\n42\n\"after\"\n</code-example>\n<p translation-result=\"on\">这证明 <code>foo</code> 的订阅是完全同步的，就像一个函数一样。</p><p translation-origin=\"off\">Which proves the subscription of <code>foo</code> was entirely synchronous, just like a function.</p>\n\n<p translation-result=\"on\"><span class=\"informal\">Observables 能够同步或异步地传递值。</span></p><p translation-origin=\"off\"><span class=\"informal\">Observables are able to deliver values either synchronously or asynchronously.</span></p>\n\n<p translation-result=\"on\">Observable 和函数有什么区别？ <strong>Observables 可以随着时间的推移“返回”多个值</strong>，而函数不能。你不能这样做：</p><p translation-origin=\"off\">What is the difference between an Observable and a function? <strong>Observables can \"return\" multiple values over time</strong>, something which functions cannot. You can't do this:</p>\n\n<code-example language=\"ts\">\nfunction foo() {\n  console.log('Hello');\n  return 42;\n  return 100; // dead code. will never happen\n}\n</code-example>\n<p translation-result=\"on\">函数只能返回一个值。然而，Observables 可以这样做：</p><p translation-origin=\"off\">Functions can only return one value. Observables, however, can do this:</p>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a> } from 'rxjs';\n\nconst foo = new <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>((subscriber) =&gt; {\n  console.log('Hello');\n  subscriber.next(42);\n  subscriber.next(100); // \"return\" another value\n  subscriber.next(200); // \"return\" yet another\n});\n\nconsole.log('before');\nfoo.subscribe((x) =&gt; {\n  console.log(x);\n});\nconsole.log('after');\n</code-example>\n<p translation-result=\"on\">具有同步输出：</p><p translation-origin=\"off\">With synchronous output:</p>\n\n<code-example language=\"none\">\n\"before\"\n\"Hello\"\n42\n100\n200\n\"after\"\n</code-example>\n<p translation-result=\"on\">但你也可以异步“返回”值：</p><p translation-origin=\"off\">But you can also \"return\" values asynchronously:</p>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a> } from 'rxjs';\n\nconst foo = new <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>((subscriber) =&gt; {\n  console.log('Hello');\n  subscriber.next(42);\n  subscriber.next(100);\n  subscriber.next(200);\n  setTimeout(() =&gt; {\n    subscriber.next(300); // happens asynchronously\n  }, 1000);\n});\n\nconsole.log('before');\nfoo.subscribe((x) =&gt; {\n  console.log(x);\n});\nconsole.log('after');\n</code-example>\n<p translation-result=\"on\">具有输出：</p><p translation-origin=\"off\">With output:</p>\n\n<code-example language=\"none\">\n\"before\"\n\"Hello\"\n42\n100\n200\n\"after\"\n300\n</code-example>\n<p translation-result=\"on\">结论：</p><p translation-origin=\"off\">Conclusion:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><code>func.call()</code> 意思是“<em> 同步给我一个值 </em>”</p><p translation-origin=\"off\"><code>func.call()</code> means \"<em>give me one value synchronously</em>\"</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>observable.subscribe()</code> 的意思是“<em> 给我任意数量的值，无论是同步的还是异步的 </em>”</p><p translation-origin=\"off\"><code>observable.subscribe()</code> means \"<em>give me any amount of values, either synchronously or asynchronously</em>\"</p>\n\n</li>\n</ul>\n<h2 id=\"anatomy-of-an-observable\" translation-result=\"on\">Observable 剖析<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observable#anatomy-of-an-observable\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Anatomy of an Observable<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observable#anatomy-of-an-observable\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">Observables 可以使用 <code>new <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a></code> 或<strong>创建型</strong>操作符来创建，由 Observer <strong>订阅</strong>后，<strong>执行</strong>以便向 Observer 传递 <code>next</code> / <code>error</code> / <code>complete</code> 通知，并且它们的执行可能会被<strong>释放</strong>。这四个方面都编码在同一个 Observable 实例中，但其中一些方面也会和其它类型有关，例如 Observer 和 Subscription。</p><p translation-origin=\"off\">Observables are <strong>created</strong> using <code>new <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a></code> or a creation operator, are <strong>subscribed</strong> to with an Observer, <strong>execute</strong> to deliver <code>next</code> / <code>error</code> / <code>complete</code> notifications to the Observer, and their execution may be <strong>disposed</strong>. These four aspects are all encoded in an Observable instance, but some of these aspects are related to other types, like Observer and Subscription.</p>\n\n<p translation-result=\"on\">Observable 的核心关注点：</p><p translation-origin=\"off\">Core Observable concerns:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><strong>创建</strong> Observables</p><p translation-origin=\"off\"><strong>Creating</strong> Observables</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><strong>订阅</strong> Observables</p><p translation-origin=\"off\"><strong>Subscribing</strong> to Observables</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><strong>执行</strong> Observable</p><p translation-origin=\"off\"><strong>Executing</strong> the Observable</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><strong>释放</strong> Observables</p><p translation-origin=\"off\"><strong>Disposing</strong> Observables</p>\n\n</li>\n</ul>\n<h3 id=\"creating-observables\" translation-result=\"on\">创建 Observables<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observable#creating-observables\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Creating Observables<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observable#creating-observables\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><code><a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a></code> 的构造函数接受一个参数：<code>subscribe</code> 函数。</p><p translation-origin=\"off\">The <code><a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a></code> constructor takes one argument: the <code>subscribe</code> function.</p>\n\n<p translation-result=\"on\">下面的示例创建一个 Observable 以每秒向订阅者发送字符串 <code>'hi'</code>。</p><p translation-origin=\"off\">The following example creates an Observable to emit the string <code>'hi'</code> every second to a subscriber.</p>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a> } from 'rxjs';\n\nconst <a href=\"api/index/const/observable\" class=\"code-anchor\">observable</a> = new <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>(function subscribe(subscriber) {\n  const id = setInterval(() =&gt; {\n    subscriber.next('hi');\n  }, 1000);\n});\n</code-example>\n<p translation-result=\"on\"><span class=\"informal\">可以使用 <code>new <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a></code>。最常见的是， Observable 是使用创建函数创建的，例如 <code><a href=\"api/index/function/of\" class=\"code-anchor\">of</a></code>、<code><a href=\"api/index/function/from\" class=\"code-anchor\">from</a></code>、<code><a href=\"api/index/function/interval\" class=\"code-anchor\">interval</a></code> 等。</span></p><p translation-origin=\"off\"><span class=\"informal\">Observables can be created with <code>new <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a></code>. Most commonly, observables are created using creation functions, like <code><a href=\"api/index/function/of\" class=\"code-anchor\">of</a></code>, <code><a href=\"api/index/function/from\" class=\"code-anchor\">from</a></code>, <code><a href=\"api/index/function/interval\" class=\"code-anchor\">interval</a></code>, etc.</span></p>\n\n<p translation-result=\"on\">在上面的例子中，<code>subscribe</code>（订阅）函数是描述 Observable 的最重要的部分。让我们看看订阅是什么意思。</p><p translation-origin=\"off\">In the example above, the <code>subscribe</code> function is the most important piece to describe the Observable. Let's look at what subscribing means.</p>\n\n<h3 id=\"subscribing-to-observables\" translation-result=\"on\">订阅 Observables<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observable#subscribing-to-observables\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Subscribing to Observables<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observable#subscribing-to-observables\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">示例中的 Observable <code><a href=\"api/index/const/observable\" class=\"code-anchor\">observable</a></code> 可以被<em>订阅</em>，如下所示：</p><p translation-origin=\"off\">The Observable <code><a href=\"api/index/const/observable\" class=\"code-anchor\">observable</a></code> in the example can be <em>subscribed</em> to, like this:</p>\n\n<code-example language=\"ts\">\nobservable.subscribe((x) =&gt; console.log(x));\n</code-example>\n<p translation-result=\"on\"><code>observable.subscribe</code> 和 <code>new <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>(function subscribe(subscriber) {...})</code> 中的 <code>subscribe</code> 同名并非巧合。在本库中，它们是不同的，但从使用角度，你可以认为它们在概念上是相同的。</p><p translation-origin=\"off\">It is not a coincidence that <code>observable.subscribe</code> and <code>subscribe</code> in <code>new <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>(function subscribe(subscriber) {...})</code> have the same name. In the library, they are different, but for practical purposes you can consider them conceptually equal.</p>\n\n<p translation-result=\"on\">这显示了 <code>subscribe</code> 调用在同一个 Observable 的多个 Observer 之间是不共享的。当以某个 Observer 调用 <code>observable.subscribe</code> 时，<code>new <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>(function subscribe(subscriber) {...})</code> 中的 <code>subscribe</code> 函数会针对给定的订阅者运行。对 <code>observable.subscribe</code> 的每次调用都会为给定的订阅者触发其自己的独立设置。</p><p translation-origin=\"off\">This shows how <code>subscribe</code> calls are not shared among multiple Observers of the same Observable. When calling <code>observable.subscribe</code> with an Observer, the function <code>subscribe</code> in <code>new <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>(function subscribe(subscriber) {...})</code> is run for that given subscriber. Each call to <code>observable.subscribe</code> triggers its own independent setup for that given subscriber.</p>\n\n<p translation-result=\"on\"><span class=\"informal\">订阅 Observable 就像调用一个函数，其参数是要传过去数据的回调函数。</span></p><p translation-origin=\"off\"><span class=\"informal\">Subscribing to an Observable is like calling a function, providing callbacks where the data will be delivered to.</span></p>\n\n<p translation-result=\"on\">这与 <code>addEventListener</code> / <code>removeEventListener</code> 等事件处理器 API 截然不同。使用 <code>observable.subscribe</code> 时，给定的 Observer 不会在此 Observable 中注册为监听器。此 Observable 甚至不会维护附加上来的 Observer 列表。</p><p translation-origin=\"off\">This is drastically different to event handler APIs like <code>addEventListener</code> / <code>removeEventListener</code>. With <code>observable.subscribe</code>, the given Observer is not registered as a listener in the Observable. The Observable does not even maintain a list of attached Observers.</p>\n\n<p translation-result=\"on\"><code>subscribe</code> 调用只是一个启动“ Observable 的执行”并将一些值或事件传递给该执行过程的 Observer 的方法。</p><p translation-origin=\"off\">A <code>subscribe</code> call is simply a way to start an \"Observable execution\" and deliver values or events to an Observer of that execution.</p>\n\n<h3 id=\"executing-observables\" translation-result=\"on\">执行 Observables<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observable#executing-observables\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Executing Observables<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observable#executing-observables\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><code>new <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>(function subscribe(subscriber) {...})</code> 中的代码表示一次 “Observable 执行”，这是一种惰性计算，只发生在每个订阅的 Observer 上。随着时间的推移，执行会同步或异步地产生多个值。</p><p translation-origin=\"off\">The code inside <code>new <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>(function subscribe(subscriber) {...})</code> represents an \"Observable execution\", a lazy computation that only happens for each Observer that subscribes. The execution produces multiple values over time, either synchronously or asynchronously.</p>\n\n<p translation-result=\"on\">Observable 执行可以传递三种类型的值：</p><p translation-origin=\"off\">There are three types of values an Observable Execution can deliver:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">“Next（下一个）” 通知：发送数值、字符串、对象等。</p><p translation-origin=\"off\">\"Next\" notification: sends a value such as a Number, a String, an Object, etc.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">“Error（出错）” 通知：发送 JavaScript 错误或异常。</p><p translation-origin=\"off\">\"Error\" notification: sends a JavaScript Error or exception.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">“Complete（完成）”通知：不发送值。</p><p translation-origin=\"off\">\"Complete\" notification: does not send a value.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">“Next”通知是最重要和最常见的类型：它们代表要传递给订阅者的实际数据。在 Observable 执行期间，“Error”和“Complete”通知可能只发生一次，并且只能有其中之一。</p><p translation-origin=\"off\">\"Next\" notifications are the most important and most common type: they represent actual data being delivered to a subscriber. \"Error\" and \"Complete\" notifications may happen only once during the Observable Execution, and there can only be either one of them.</p>\n\n<p translation-result=\"on\">这些约束在所谓的 <em>Observable 语法</em>或<em>契约</em>中表达得最好，写成正则表达式：</p><p translation-origin=\"off\">These constraints are expressed best in the so-called <em>Observable Grammar</em> or <em>Contract</em>, written as a regular expression:</p>\n\n<code-example language=\"none\">\nnext*(error|complete)?\n</code-example>\n<p translation-result=\"on\"><span class=\"informal\">在 Observable 执行中，可能会传递零个到无限个 Next 通知。如果发送了出错或完成通知，则之后将无法发送任何其它通知。</span></p><p translation-origin=\"off\"><span class=\"informal\">In an Observable Execution, zero to infinite Next notifications may be delivered. If either an Error or Complete notification is delivered, then nothing else can be delivered afterwards.</span></p>\n\n<p translation-result=\"on\">下面是一个 Observable 执行的示例，它传递三个 Next 通知，然后完成：</p><p translation-origin=\"off\">The following is an example of an Observable execution that delivers three Next notifications, then completes:</p>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a> } from 'rxjs';\n\nconst <a href=\"api/index/const/observable\" class=\"code-anchor\">observable</a> = new <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>(function subscribe(subscriber) {\n  subscriber.next(1);\n  subscriber.next(2);\n  subscriber.next(3);\n  subscriber.complete();\n});\n</code-example>\n<p translation-result=\"on\">Observables 严格遵守 Observable 契约，因此以下代码不会传递 Next 通知 <code>4</code> ：</p><p translation-origin=\"off\">Observables strictly adhere to the Observable Contract, so the following code would not deliver the Next notification <code>4</code>:</p>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a> } from 'rxjs';\n\nconst <a href=\"api/index/const/observable\" class=\"code-anchor\">observable</a> = new <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>(function subscribe(subscriber) {\n  subscriber.next(1);\n  subscriber.next(2);\n  subscriber.next(3);\n  subscriber.complete();\n  subscriber.next(4); // Is not delivered because it would violate the contract\n});\n</code-example>\n<p translation-result=\"on\">使用 <code>try</code> / <code>catch</code> 块将任何代码包装在 <code>subscribe</code> 中是一个好主意，如果它捕获到异常，它将传递错误通知：</p><p translation-origin=\"off\">It is a good idea to wrap any code in <code>subscribe</code> with <code>try</code>/<code>catch</code> block that will deliver an Error notification if it catches an exception:</p>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a> } from 'rxjs';\n\nconst <a href=\"api/index/const/observable\" class=\"code-anchor\">observable</a> = new <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>(function subscribe(subscriber) {\n  try {\n    subscriber.next(1);\n    subscriber.next(2);\n    subscriber.next(3);\n    subscriber.complete();\n  } catch (err) {\n    subscriber.error(err); // delivers an error if it caught one\n  }\n});\n</code-example>\n<h3 id=\"disposing-observable-executions\" translation-result=\"on\">处理 Observable 执行<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observable#disposing-observable-executions\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Disposing Observable Executions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observable#disposing-observable-executions\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">因为 Observable 执行可能是无尽的，并且 Observer 想要在有限时间内中止执行也是很常见的，所以我们需要一个用于取消执行的 API。由于每次执行只针对一个 Observer，一旦 Observer 接收完了值，它必须有办法停止执行，以避免浪费计算能力或内存资源。</p><p translation-origin=\"off\">Because Observable Executions may be infinite, and it's common for an Observer to want to abort execution in finite time, we need an API for canceling an execution. Since each execution is exclusive to one Observer only, once the Observer is done receiving values, it has to have a way to stop the execution, in order to avoid wasting computation power or memory resources.</p>\n\n<p translation-result=\"on\">当 <code>observable.subscribe</code> 被调用时，此 Observer 被附加到新创建的 Observable 执行中。此调用还会返回一个对象 <code><a href=\"api/index/class/Subscription\" class=\"code-anchor\">Subscription</a></code> ：</p><p translation-origin=\"off\">When <code>observable.subscribe</code> is called, the Observer gets attached to the newly created Observable execution. This call also returns an object, the <code><a href=\"api/index/class/Subscription\" class=\"code-anchor\">Subscription</a></code>:</p>\n\n<code-example language=\"ts\">\nconst subscription = observable.subscribe((x) =&gt; console.log(x));\n</code-example>\n<p translation-result=\"on\">Subscription 代表正在进行中的执行，并具有允许你取消该执行的最小 API。<a href=\"./guide/subscription\">在此处阅读有关 <code>Subscription</code> 类型</a>的更多信息。使用 <code>subscription.unsubscribe()</code> 你可以取消正在进行的执行：</p><p translation-origin=\"off\">The Subscription represents the ongoing execution, and has a minimal API which allows you to cancel that execution. Read more about the <a href=\"./guide/subscription\"><code>Subscription</code> type here</a>. With <code>subscription.unsubscribe()</code> you can cancel the ongoing execution:</p>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> } from 'rxjs';\n\nconst <a href=\"api/index/const/observable\" class=\"code-anchor\">observable</a> = <a href=\"api/index/function/from\" class=\"code-anchor\">from</a>([10, 20, 30]);\nconst subscription = observable.subscribe((x) =&gt; console.log(x));\n// Later:\nsubscription.unsubscribe();\n</code-example>\n<p translation-result=\"on\"><span class=\"informal\">当你订阅时，你会得到一个 Subscription，它代表正在进行的执行。只需调用 <code>unsubscribe()</code> 即可取消执行。</span></p><p translation-origin=\"off\"><span class=\"informal\">When you subscribe, you get back a Subscription, which represents the ongoing execution. Just call <code>unsubscribe()</code> to cancel the execution.</span></p>\n\n<p translation-result=\"on\">当我们使用 <code>create()</code> 创建 Observable 时，每个 Observable 都必须定义如何处理该执行的资源。你可以通过从 <code>function subscribe()</code> 中返回自定义 <code>unsubscribe</code> 函数来做到这一点。</p><p translation-origin=\"off\">Each Observable must define how to dispose resources of that execution when we create the Observable using <code>create()</code>. You can do that by returning a custom <code>unsubscribe</code> function from within <code>function subscribe()</code>.</p>\n\n<p translation-result=\"on\">例如，这就是我们使用 <code>setInterval</code> 清除定时执行集的方式：</p><p translation-origin=\"off\">For instance, this is how we clear an interval execution set with <code>setInterval</code>:</p>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a> } from 'rxjs';\nconst <a href=\"api/index/const/observable\" class=\"code-anchor\">observable</a> = new <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>(function subscribe(subscriber) {\n  // Keep track <a href=\"api/index/function/of\" class=\"code-anchor\">of</a> the <a href=\"api/index/function/interval\" class=\"code-anchor\">interval</a> resource\n  const intervalId = setInterval(() =&gt; {\n    subscriber.next('hi');\n  }, 1000);\n\n  // Provide a way <a href=\"api/index/function/of\" class=\"code-anchor\">of</a> canceling and disposing the <a href=\"api/index/function/interval\" class=\"code-anchor\">interval</a> resource\n  return function unsubscribe() {\n    clearInterval(intervalId);\n  };\n});\n</code-example>\n<p translation-result=\"on\">就像 <code>observable.subscribe</code> 效仿了 <code>new <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>(function subscribe() {...})</code> 一样，我们从 <code>subscribe</code> 返回的 <code>unsubscribe</code> 在概念上也相当于 <code>subscription.unsubscribe</code>。事实上，如果我们删除围绕这些概念的 ReactiveX 类型，我们就会得到相当简单的 JavaScript。</p><p translation-origin=\"off\">Just like <code>observable.subscribe</code> resembles <code>new <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>(function subscribe() {...})</code>, the <code>unsubscribe</code> we return from <code>subscribe</code> is conceptually equal to <code>subscription.unsubscribe</code>. In fact, if we remove the ReactiveX types surrounding these concepts, we're left with rather straightforward JavaScript.</p>\n\n<code-example language=\"ts\">\nfunction subscribe(subscriber) {\n  const intervalId = setInterval(() =&gt; {\n    subscriber.next('hi');\n  }, 1000);\n\n  return function unsubscribe() {\n    clearInterval(intervalId);\n  };\n}\n\nconst unsubscribe = subscribe({ next: (x) =&gt; console.log(x) });\n\n// Later:\nunsubscribe(); // dispose the resources\n</code-example>\n<p translation-result=\"on\">我们使用诸如 Observable、Observer 和 Subscription 之类的 Rx 类型的原因是为了获得安全性（例如 Observable Contract）以及与 Operators 的可组合性。</p><p translation-origin=\"off\">The reason why we use Rx types like Observable, Observer, and Subscription is to get safety (such as the Observable Contract) and composability with Operators.</p>\n\n\n</div>\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - ./guide/subscription\n - /api/index/class/Observable\n - /deprecations/to-promise\n - api/index/class/Observable\n - api/index/class/Subscription\n - api/index/const/observable\n - api/index/function/from\n - api/index/function/interval\n - api/index/function/of\n - guide/observable#anatomy-of-an-observable\n - guide/observable#creating-observables\n - guide/observable#disposing-observable-executions\n - guide/observable#executing-observables\n - guide/observable#observable\n - guide/observable#observable-剖析\n - guide/observable#observables-as-generalizations-of-functions\n - guide/observable#observables-是对函数的泛化\n - guide/observable#observable可观察者\n - guide/observable#pull-versus-push\n - guide/observable#subscribing-to-observables\n - guide/observable#创建-observables\n - guide/observable#处理-observable-执行\n - guide/observable#执行-observables\n - guide/observable#拉取与推送\n - guide/observable#订阅-observables\n - https://developer.mozilla.org/en-US/docs/Glossary/Function\n - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\n - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols\n - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*\n-->"}